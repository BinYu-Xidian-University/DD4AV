#!/usr/bin/env python3

# This is the structrue of Share Memory class
SHARE_THREAD_NUM = 100
SHARE_ARRAY_SIZE = 3964
# typedef struct Sched_Info {
#	uint64_t time;								// the execution time of the program (nsec)
#	unsigned int N;								// number of threads concerned
#	unsigned int M;								// number of kep points per thread
#	unsigned int TestedPeriod;					// It took several period in testing engine
#	uint16_t kpNumArray[SHARE_THREAD_NUM];	    // the specific kpNum of each My_tid Thread, only consider almost 10 thread
#	uint16_t kp[SHARE_ARRAY_SIZE];			    // how many times should a thread yield before a kp
#	uint16_t kpLoc[SHARE_ARRAY_SIZE];		    // the hash ID of Key Point
#	uint16_t kpOrder[SHARE_ARRAY_SIZE];		    // recored the order of key points
#   uint16_t kpdynamicaddress[SHARE_ARRAY_SIZE];	// recorded the dynamic adress  kladd
# } sched_info;

# =================================================================================

import sys, subprocess, time, interleaving, os, getopt, copy, signal
from external_def import get_ASAN_error_type, formateTime, filled_with_zero, calculate_coverage_hashID, \
    add_to_explore_dict, print_Info_from_shm, getMaxNuminPattern, is_redundant_with_prefix, zero_num
from collections import OrderedDict
from datetime import datetime
from ast import literal_eval
from ctypes import *
from interleaving import *
from bp_sched import *
from sbp_sched import *
from sbp_sched_mixed_end import *
from ipc import *
from itertools import combinations, permutations
import numpy as np

DebugInfo = False  # Set “True”, if you want to get debug information

FILE_SAVED_MAXNUM = 10000  # The max number of error interleavings we can saved
subprocessTimeout = 5
rlts = []  # the set of unique results generated by the c program
statusL = []  # the set of unique status generated by the c program
startTime = time.time()
lastTime = time.time()  # the time when a new result is found
rounds = lastRound = 0
output_num = [0]  # the number of different outputs
total_errors_interleavings = [0]  # the number of errors
total_timeouts_interleavings = [0]  # the number of timeouts
recordERR = 1
check_STDOUT = 1  # Set 2 if you want to record diff result
check_STDERR = 1  # Set 1 if you want to record err result
kpMaxNumArray = [0] * SHARE_THREAD_NUM
parentArray = [0] * SHARE_THREAD_NUM
parentArrayCopy = [0] * SHARE_THREAD_NUM

def memmove_pattern_list(PatternList):
    tmp = []
    for t in PatternList:
        tmp += t
    tmparr = (c_uint16 * len(tmp))(*tmp)
    memmove(ADDR + sizeof(c_ulonglong) + sizeof(c_uint) * 3 + sizeof(c_uint16) * SHARE_THREAD_NUM, tmparr,
            sizeof(c_uint16) * len(tmp))


# create subprocess according to the value of check_STDOUT and check_STDERR
def create_DBDS_subprocess(check_STDOUT, check_STDERR):
    process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    return process

def get_priority_from_txt(file_name): # rxadd
    # 这个函数用于从 priority.txt 文件中获取任务的优先级信息
    # 在这里你可以实现从文件中读取信息的逻辑
    # 在这个例子中，我们只是返回一个固定的字典作为示例
    return {'task_main': 0, 'isr1': 1, 'isr2': 2}

def count_lines(static_info, priority): # rxadd
    counts = [[] for _ in range(len(priority))]
    for item in static_info:
        function_name = item[3]
        if function_name in priority:
            priority_index = priority[function_name]
            counts[priority_index].append(priority_index)
    return [len(count) for count in counts]

def schedule_generator(keypoints):  # rxadd
    # 初始化中间序列
    intermediate_sequences = [keypoints[0]]

    # 循环处理每个线程
    for i in range(1, len(keypoints)):
        current_thread = keypoints[i]
        new_sequences = []

        # 遍历之前生成的所有中间序列
        for sequence in intermediate_sequences:
            # 将当前线程的关键点插入到每个位置,j初始化为len(sequence)，这样可以在末尾插入，每次减一，直到0
            for j in range(len(sequence),-1,-1):
                new_sequence = sequence[:j] + current_thread + sequence[j:]
                new_sequences.append(new_sequence)

        intermediate_sequences = new_sequences

    # 打印所有生成的序列
    return intermediate_sequences

def fill_keypoints(keyPoints_list): # rxadd
    # i 是元素的索引，count 是元素的值 = keyPoints_list[i]
    # [i] * count 创建了一个包含 i 元素重复 count 次的子列表
    return [[i] * count for i, count in enumerate(keyPoints_list)]


def split_into_groups(lst): # rxadd
    result = []
    current_group = []
    current_value = None

    for value in lst:
        if value != current_value:
            if current_group:
                result.append(current_group)
            current_group = [value]
            current_value = value
        else:
            current_group.append(value)

    if current_group:
        result.append(current_group)

    return result

def get_info_from_staticanalysis(filename):  # kladd
    result = []
    with open(filename, 'r') as file:
        for line in file:
            try:
                parsed_line = literal_eval(line.strip())
                result.append(parsed_line)
            except SyntaxError:
                print(f"Ignoring line due to syntax error: {line.strip()}")
            except ValueError:
                print(f"Ignoring line due to value error: {line.strip()}")
    return result



# ================= Start Parameter processing phase ========================

try:
    opts, args = getopt.getopt(sys.argv[1:], "hlyozer:m:n:d:t:f:",
                               ["help", "enable-memoryleak", "skip-enter", "overhead-testing", "full_deep_run=",
                                "no-prefix", "reproduceFile=", "memPairConsidered=", "varNumConsidered=", "bugDepth=",
                                "timeout=", "runs="])
except getopt.GetoptError as err:
    print(err)  # will print something like "option -a not recognized"
    sys.exit(2)
    pass
print("opts:", opts)
print("args:", args)

# load static_analysis.***
exename = args[0].replace("./", "")
if 'LD_LIBRARY_PATH=' in exename and '' in exename:
    exename = exename[exename.rfind('/') + 1:]
if '/' in exename:
    SlashIndex = exename.rfind('/')
    Static_Analysis_FileName = exename[0:SlashIndex + 1] + "static_analysis." + exename[SlashIndex + 1:]
else:
    Static_Analysis_FileName = "static_analysis." + exename

sorted_schedules = []
if os.path.exists(Static_Analysis_FileName):
    static_info = get_info_from_staticanalysis(Static_Analysis_FileName)
    if os.path.exists("priority.txt"): # rxadd
        priority = get_priority_from_txt("priority.txt") # rxadd
        line_counts = count_lines(static_info, priority) # rxadd
        threads = fill_keypoints(line_counts)           # rxadd
        mid = schedule_generator(threads)  # rxadd
        static_schedules = []
        for each in mid:
            static_schedules.append(split_into_groups(each))
        sorted_schedules = sorted(static_schedules, key=len)
    else:
        print("priority.txt does not exist.")

else:
    print(f"Static analysis file {Static_Analysis_FileName} does not exist.")

for opt, arg in opts:
    if opt in ("-h", "--help"):
        print(
            './run_PDS.py "cmd" or ./run_PDS.py -r <reproduceFile> or ./run_PDS.py -n <varNumConsidered> "cmd" or ./run_PDS.py -m <memPairConsidered> or ./run_PDS.py -d <bugDepth> "cmd"')
        sys.exit()
    elif opt in ("-y", "--skip-enter"):
        skipEnter = 1
    elif opt in ("-d", "--bugDepth"):
        if arg.isdigit():
            bugDepth = int(arg)
            # print("bugDepth:", bugDepth)
            period_limit = bugDepth + 1
        else:
            print("bugDepth is not a digit.")
            sys.exit()

# Processing parameters/argv
DBDS_Command = ['sudo', 'Dry_Run=0', 'DBDS_Run=1', 'ASAN_OPTIONS=abort_on_error=1:detect_leaks=0',
                'TSAN_OPTIONS=report_bugs=1']  # the command for running program (adding sudo)


if (len(args) > 0):
    for i in range(0, len(args)):
        DBDS_Command.append(args[i])

DBDS_Command_Str = ' '.join(DBDS_Command)
# print(DryRun_Command)
# load npz data for memory Info
pureSoList = []
memGroupList = []
memPairList = []

# According to PERIOD evaluation
first_buggy_schedule = -1
find_buggy_schedule = False
total_schedule = 0
total_buggy_schedule = 0
period_limit = 5;


for iterPeriod in range(2, period_limit + 1):
    print("=======周期为:", iterPeriod, "=======")
    for inter in sorted_schedules:  # rxadd
        if (len(inter) == iterPeriod):
            rounds = rounds + 1
            print("\033[4;36mtest", str(format(rounds, "0>4")) + ":\033[0m ", end="")

            print(inter)

            # create subprocess
            process = subprocess.Popen(DBDS_Command, close_fds=True, preexec_fn=os.setpgrp, stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE)

            try:
                process.communicate(timeout=subprocessTimeout)

            except subprocess.TimeoutExpired:
                print("\033[31m Subprocess Timeout\033[0m")
                subprocess.check_call(["sudo", "kill", str(process.pid)])

            except Exception as e:
                print("\033[34m\tUnknown Exception" + "\033[0m")
                print(e)
                pass



print("\033[4;36mEnd Testing!\n\033[0m")

print("\033[1;35m")
# print('Total Error Interleavings:', total_errors_interleavings[0])
# print('Total Timeouts Interleavings:', total_timeouts_interleavings[0])
# print(len(statusL), 'status found:')
# print("\t", statusL)
# print(len(rlts), 'results found:')
# for each in rlts:
#     print("\t", each)
print('-' * 50)
# print('  ')
# for i in GlobalAVSet:
#     print(i)
# print('\tLast New Find\t\tTotal')
# print('Round\t{0}\t\t\t{1}'.format(lastRound, rounds))
print('Total Round:', (rounds))
print('First_buggy_round:{0}\t\tTotal_buggy_rounds:{1}\tTotal_rounds:{2}'.format(first_buggy_schedule,
                                                                                 total_buggy_schedule, rounds))
print('bugDepth:', bugDepth)
# print('Time\t' + formateTime(lastTime - startTime), end="")
# print('\t\t' + formateTime(time.time() - startTime))
print('TotalTime\t\t\t\t' + formateTime(time.time() - startTime))
# print('DynamicExecTime\t\t\t' + formateTime(DynamicExecutionTime))
# print('AtomicityViolationTime\t' + formateTime(SumTime))
print('\t\t')
print("\033[0m")
exit()